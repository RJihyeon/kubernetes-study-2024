---
챕터: 6.1 - 6.2
발제: 유지민
일자: 24.09.28
---
## 6.1 쿠버네티스를 시작하기 전에

### 오브젝트

> 모든 리소스는 오브젝트 형태로 관리됩니다.
>
- 쿠버네티스에선 모든 것이 *오브젝트*다!
    - 컨테이너는 물론이고 설정값, 비밀값까지도 전부
- 오브젝트를 명령어로 직접 관리할 수 있지만 보통 YAML 파일을 정의해서 사용함
    - 마치 `docker run -p 80:80 -v ./data:/data ...` 대신 도커 컴포즈 파일을 쓰는 것처럼
    - 선언형 패러다임

### 클러스터

![https://kubernetes.io/images/docs/components-of-kubernetes.svg](https://kubernetes.io/images/docs/components-of-kubernetes.svg)

쿠버네티스 클러스터는 보통 여러 대의 **노드**로 구성됨

- 노드란?
    - 작업을 수행하는 머신을 지칭함
    - 실제 물리 머신을 지칭할 수도 있고 가상 머신(VM)을 지칭할 수도 있음
- 노드의 종류
    - 마스터: 주로 클러스터를 관리하는 역할 (Control plane이라고도 함)
    - 워커: 실질적으로 작업을 수행하는 역할

또한 쿠버네티스 클러스터는 여러 개의 **컴포넌트**로 구성됨

- 노드끼리 어떻게 통신함?
    - 모든 노드에 포함된 `kubelet`이라는 컴포넌트를 통해서
- 클러스터는 어떻게 관리함?
    - `API 서버`, `컨트롤러 매니저`, `스케줄러` 컴포넌트 등
- 컨테이너는 어떻게 돌림?
    - `컨테이너 런타임 인터페이스` (도커 말고도 종류가 다양함)
    - OCI 표준을 구현하기만 하면 됨
- 컨테이너끼리는 어떻게 통신함?
    - `네트워크 플러그인(CNI Plugin)`

---

## 6.2 파드(Pod): 컨테이너를 다루는 기본 단위

> A *Pod* (as in a pod of whales or pea pod) is a group of one or more containers, with shared storage and network resources, and a specification for how to run the containers.
>

도커의 기본 단위가 컨테이너라면 k8s의 기본 단위는 **파드**임

- 하나 혹은 여러 개의 컨테이너를 하나로 묶음

### 파드 사용하기

파드는 오브젝트다. 편의상 단일 컨테이너로 구성된 파드를 정의해보자. 파드 오브젝트의 YAML 파일은 이런 식으로 정의할 수 있다.

```yaml
apiVersion: v1
kind: Pod # 오브젝트 종류가 파드임을 나타냄
metadata: # 파드의 메타데이터
	name: my-nginx-pod # 파드 이름
spec: # 파드를 생성하기 위한 상세 정보를 명시
	containers:
		- name: my-nginx-container # 파드 내 컨테이너 이름
			image: nginx:latest # 컨테이너 이미지
			ports:
				- containerPort: 80 # 도커로 치면 EXPOSE 80 (아직 외부로 노출이 안된거임)
					protocol: TCP
```

> [!TIP] 그럼 클러스터 외부에서 80번 포트로 어떻게 접근하지?
>
> ⇒ `서비스(Service)`라는 오브젝트를 생성해줘야 함. 서비스가 없다면 이 파드는 클러스터 내부에서만 접근 가능함.

> [!TIP] 그럼 클러스터 내부에서는 nginx 파드의 80번 포트에 어떻게 접근하지?
>
> ⇒ 클러스터에 속한 노드 중 하나에 접속하면 됨
>
> ⇒ EC2 머신에 접속할 때 처럼 SSH로 노드에 접속
>
> ⇒ 노드에 들어가서 `curl <파드의 IP>:80` 하면 성공

파드 뿐만 아니라 k8s의 다른 오브젝트를 정의할 때에도 `apiVersion`, `kind`, `metadata`, `spec`을 기본 틀로 잡고 YAML을 작성함. 이렇게 작성한 YAML 파일을 아래의 명령어와 같이 사용하여 파드를 생성할 수 있음.

```bash
kubectl apply -f nginx-pod.yaml
```

파드가 제대로 생성되었는 지 확인해보자.

- 모든 파드 목록 출력
    - `kubectl get pods`
- 특정 파드의 상세 정보 출력
    - `kubectl describe pods <pod-name>`
    - 여기에서 파드의 IP 주소도 출력해줌
        - 하지만 외부에서 접근할 수 있는 IP는 아님
        - 클러스터가 이 파드에 할당해준 내부용 IP임
        - 클러스터가 IP를 할당하는 방식은 책 뒷부분에서 나오지 않을까?

`docker exec`처럼 k8s에서도 `kubectl exec -it <pod-name>`으로 파드 안에서 셸을 실행할 수 있음

- 파드의 컨테이너로 들어가는 게 아니라 진짜 그냥 “파드” 안으로 들어가는 것
- 마찬가지로 `kubectl logs <pod-name>`도 파드의 로그를 출력함

### 파드 vs. 컨테이너

그렇다면 왜 여러 컨테이너를 “파드”로 묶어서 사용할까?

- 컨테이너들이 **리눅스 네임스페이스**를 공유하도록 하기 위해서
- 네임스페이스를 공유한다는 것은…
    - 스토리지를 공유한다
    - 네트워크 네임스페이스를 공유한다
        - 파드 안에 있는 컨테이너끼리는 로컬호스트로 접근 가능하다는 뜻
- 도커 컨테이너에서의 네트워크를 생각해보자
    - 컨테이너는 별도의 독립된 환경이기 때문에 각 컨테이너는 별도의 IP를 가짐
        - 각 컨테이너는 별도의 네트워크 네임스페이스를 갖는다는 뜻
    - 도커에서 네트워크(`bridge`, `host` 등)를 구성해줘야 컨테이너끼리 통신이 가능
        - 비로소 컨테이너들이 네트워크 네임스페이스를 공유할 수 있게됨

### 완전한 애플리케이션으로서의 파드

하나의 파드는 하나의 완전한 애플리케이션

- 특정 컨테이너와 함께 실행되어야 하는 컨테이너들을 파드로 묶어버리자
    - 이런 부가적인 컨테이너들을 사이드카(sidecar)라고 부름
- 하나의 온전한 기능을 수행하도록 여러 컨테이너를 묶은 단위를 파드라고 할 수 있음%